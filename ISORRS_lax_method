# module designed to replace numerical method used with the lax method
# this is currently a work in progress and thus is not yet intergrated into the equations module

def density_lax_ion(dt,A,A_0,A_1,rho_0,rho_1,u_0,u_1,S,dx):
#returns: ion density
#requires: time step, area vectors for current, previous grid position and 
#          next grid position, mass density of previous and next grid
#          position, velocity of previous and next grid position,
#          mass production rate, spatial step
#ref: Gombozi+1985, Glocer+ 2007 etc
    Z = (0.5*((A_1*rho_1)+(A_0*rho_0)))
    Y = ((A_1*rho_1*u_1) - (A_0*rho_0*u_0))
    return (((Z)- ((dt/(2*dx))*(Y)) +dt*A*S)/A)
#input as: dt,A[i],A[i-1],A[i+1],ions[l]["rho"][2:-2:,i-1],ions[l]["rho"][2:-2,i+1],ions[l]["u"][2:-2,i-1],ions[l]["u"][2:-2,i+1],ions[l]["S"][2:-2],dz
#          dt,A[2:-2],A[1:-3],A[3:-1],ions[l]["rho"][1:-3:,i],ions[l]["rho"][3:-1,i],ions[l]["u"][1:-3,i],ions[l]["u"][3:-1,i],ions[l]["S"][2:-2],dz

def velocity_lax_ion(dt,A,A_0,A_1,rho,rho_0,rho_1,u_0,u_1,P_0,P_1,e_charge,m_i,E,ag,ac,dMdt,S,dx,rho_new):
#returns: ion velocity
#requires: time step, area vectors for current, previous grid position and 
#          next grid position, mass density for current, previous and next 
#          grid position, velocity of previous and next grid position,
#          pressure at previous and next grid position, charge of electron,
#          mass of ion, electric field, gravitational acceleration,
#          centrifugal force, momentum exchange rate, mass production rate,
#          spatial step, updated mass density from density_lax
#ref: Gombozi+1985, Glocer+ 2007 etc
    Z = (0.5*((A_1*rho_1*u_1)+(A_0*rho_0*u_0)))
    Y = ((A_1*rho_1*u_1*u_1)-(A_0*rho_0*u_0*u_0))
    X = ((e_charge/m_i)*E - ag + ac)
    return((Z)- (dt/(2*dx)*(Y))-(A*(dt/(2*dx))*(P_1 - P_0))+ (dt*(A*rho*(X)+dMdt + (A*rho*S)))/(A*rho_new))
#input as: dt,A[i],A[i-1],A[i+1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][2:-2:,i-1],tmp_ions[l]["rho"][2:-2,i+1],ions[l]["u"][2:-2,i-1],ions[l]["u"][2:-2,i+1],ions[l]["P"][2:-2,i-1],ions[l]["P"][2:-2,i+1],e_charge,ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i]
#          dt,A[2:-2],A[1:-3],A[3:-1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][1:-3:,i],tmp_ions[l]["rho"][3:-1,i],ions[l]["u"][1:-3,i],ions[l]["u"][3:-1,i],ions[l]["P"][1:-3,i],ions[l]["P"][3:-1,i], e_charge, ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i]

def pressure_lax_ion(dt,A,A_0,A_1,rho,rho_0,rho_1,u,u_0,u_1,P_0,P_1,gamma,e_charge,m_i,E,ag,ac,dMdt,dEdt,S,dx,rho_new,u_new):
#returns: ion pressure
#requires: time step, area vectors for current, previous grid position and 
#          next grid position, mass density for current, previous and next 
#          grid position, velocity of current, previous and next grid position,
#          pressure at previous and next grid position, specific heat ratio,
#          charge of electron, mass of ion, electric field, gravitational 
#          acceleration, centrifugal force, momentum exchange rate, energy  
#          exchange rate, mass production rate, spatial step, updated mass  
#          density from density_lax_ion, updated velocity from 
#          velocity_lax_ion
#ref: Gombozi+1985, Glocer+ 2007 etc    
    Z = ((0.5*A_1*rho_1*u_1*u_1)+(A_1*P_1*(1/(gamma-1))))
    Y = ((0.5*A_0*rho_0*u_0*u_0)+(A_0*P_0*(1/(gamma-1))))
    X = ((0.5*A_1*rho_1*u_1*u_1*u_1)-(A_1*u_1*P_1*(gamma/(gamma-1))))
    W = ((0.5*A_0*rho_0*u_0*u_0*u_0)-(A_0*u_0*P_0*(gamma/(gamma-1))))
    V = ((A*u*rho*((e_charge/m_i)*E-ag+ac)))
    return ((((0.5*(Z)+(Y))-((dt/(2*dx))*(X)-(W))+(dt*((V)+dMdt +dEdt +(0.5*A*u*u*S))))-(0.5*A*rho_new*u_new*u_new))*((gamma-1)/A))
#input as: dt,A[i],A[i-1],A[i+1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][2:-2:,i-1],tmp_ions[l]["rho"][2:-2,i+1],tmp_ions[l]["u"][2:-2,i],tmp_ions[l]["u"][2:-2,i-1],tmp_ions[l]["u"][2:-2,i+1],ions[l]["P"][2:-2,i-1],ions[l]["P"][2:-2,i+1],gamma,e_charge,ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],dEdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i],ions[l]["u"][2:-2,i]
#          dt,A[2:-2],A[1:-3],A[3:-1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][1:-3:,i],tmp_ions[l]["rho"][3:-1,i],tmp_ions[l]["u"][2:-2,i],tmp_ions[l]["u"][1:-3,i],tmp_ions[l]["u"][3:-1,i],ions[l]["P"][1:-3,i],ions[l]["P"][3:-1,i],gamma,e_charge,ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],dEdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i],ions[l]["u"][2:-2,i]

def temperature_electron(dt,A,A_0,A_1,rho,u,u_0,u_1,T,T_0,T_1,gamma,S,dx):
#returns: electron temperature
#requires: time step,area vectors for current, previous grid position and 
#          next grid position, mass density for current grid position, 
#          velocity of current, previous and next grid position, temperature
#          temperature at previous and current grid position, gamma, mass
#          production rate, spatial step
#ref: Gombozi+1985, Glocer+ 2007 etc
    Z = (rho*u*(dt/(2*dx))*(T_1-T_0))
    Y = (T*dt*(S+((gamma-1)/A)*rho*(1/(2*dx))*((A_1*u_1)-(A_0*u_0))))
    return((0.5*(T_1-T_0))+((Z)-(Y)/rho))
#input as: dt,A[i],A[i-1],A[i+1],electrons["rho"][2:-2,i],electrons["u"][2:-2,i],electrons["u"][2:-2,i-1],electrons["u"][2:-2,i+1],electrons["T"][2:-2,i],electrons["T"][2:-2,i-1],electrons["T"][2:-2,i+1],gamma,electrons["S"][2:-2],dz
#          dt,A[2:-2],A[1:-3],A[3:-1],electrons["rho"][2:-2,i],electrons["u"][2:-2,i],electrons["u"][1:-3,i],electrons["u"][3:-1,i],electrons["T"][2:-2,i],electrons["T"][1:-3,i],electrons["T"][3:-1,i],gamma,electrons["S"][2:-2],dz
