# module designed to replace numerical method used with the lax method
# this is currently a work in progress and thus is not yet intergrated into the equations module

def density_lax_ion(dt,A,rho,u,S,dx):
    import numpy as np
#returns: ion density
#requires: time step, area vectors for current, previous grid position and
#          next grid position, mass density of previous and next grid
#          position, velocity of previous and next grid position,
#          mass production rate, spatial step
#ref: Gombozi+1985, Glocer+ 2007 etc
    # Z = (0.5*((A_1*rho_1)+(A_0*rho_0)))
    # Y = ((A_1*rho_1*u_1) - (A_0*rho_0*u_0))
    # return (((Z)- ((dt/(2*dx))*(Y)) +dt*A*S)/A)
    phi = dt*A*S
    new_rho = ((0.5*(np.roll(A*rho,-1) + np.roll(A*rho,1)) - ((0.5*dt/dx)*(np.roll(A*rho*u,-1)-np.roll(A*rho*u,1)))+phi)/A)

    rho = new_rho[2:-2]
    return rho
#input as: dt,A,ions[l]["rho"][:,i-1],ions[l]["u"][:,i-1],ions[l]["S"],dz

# OLD SECTION PRE-ROLL FUNCTION
#input as: dt,A[i],A[i-1],A[i+1],ions[l]["rho"][2:-2:,i-1],ions[l]["rho"][2:-2,i+1],ions[l]["u"][2:-2,i-1],ions[l]["u"][2:-2,i+1],ions[l]["S"][2:-2],dz
#          dt,A[2:-2],A[1:-3],A[3:-1],ions[l]["rho"][1:-3:,i],ions[l]["rho"][3:-1,i],ions[l]["u"][1:-3,i],ions[l]["u"][3:-1,i],ions[l]["S"][2:-2],dz
#dt,A,A_0,A_1,rho_0,rho_1,u_0,u_1,S,dx):


def velocity_lax_ion(dt,A,rho,u,P,e_charge,m_i,E,ag,ac,dMdt,S,dx,rho_new):
#returns: ion velocity
#requires: time step, area vectors for current, previous grid position and
#          next grid position, mass density for current, previous and next
#          grid position, velocity of previous and next grid position,
#          pressure at previous and next grid position, charge of electron,
#          mass of ion, electric field, gravitational acceleration,
#          centrifugal force, momentum exchange rate, mass production rate,
#          spatial step, updated mass density from density_lax
#ref: Gombozi+1985, Glocer+ 2007 etc
    import numpy as np

    Z = (0.5*(np.roll(A*rho*u,-1) + np.roll(A*rho*u,1)))
    Y = (np.roll(A*rho*u*u,-1) + np.roll(A*rho*u*u,1))
    X = ((E*(e_charge/m_i)) - ag + ac)
    phi = (dt*(A*rho*(X)+dMdt + (A*rho*S)))
    new_u = ((Z - ((0.5*dt/dx*(Y))-(A*(0.5*dt/dx)*(np.roll(P,-1) + np.roll(P,1)))+phi))/(A*rho_new))

    u = new_u[2:-2]
    return u

# OLD SECTION PRE-ROLL FUNCTION
    # Z = (0.5*((A_1*rho_1*u_1)+(A_0*rho_0*u_0)))
    # Y = ((A_1*rho_1*u_1*u_1)-(A_0*rho_0*u_0*u_0))
    # X = ((e_charge/m_i)*E - ag + ac)
    #return((Z)- (dt/(2*dx)*(Y))-(A*(dt/(2*dx))*(P_1 - P_0))+ (dt*(A*rho*(X)+dMdt + (A*rho*S)))/(A*rho_new))
#(dt,A,A_0,A_1,rho,rho_0,rho_1,u_0,u_1,P_0,P_1,e_charge,m_i,E,ag,ac,dMdt,S,dx,rho_new)
#input as: dt,A[i],A[i-1],A[i+1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][2:-2:,i-1],tmp_ions[l]["rho"][2:-2,i+1],ions[l]["u"][2:-2,i-1],ions[l]["u"][2:-2,i+1],ions[l]["P"][2:-2,i-1],ions[l]["P"][2:-2,i+1],e_charge,ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i]
#          dt,A[2:-2],A[1:-3],A[3:-1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][1:-3:,i],tmp_ions[l]["rho"][3:-1,i],ions[l]["u"][1:-3,i],ions[l]["u"][3:-1,i],ions[l]["P"][1:-3,i],ions[l]["P"][3:-1,i], e_charge, ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i]

def pressure_lax_ion(dt,A,rho,u,P,gamma,e_charge,m_i,E,ag,ac,dMdt,dEdt,S,dx,rho_new,u_new):
#returns: ion pressure
#requires: time step, area vectors for current, previous grid position and
#          next grid position, mass density for current, previous and next
#          grid position, velocity of current, previous and next grid position,
#          pressure at previous and next grid position, specific heat ratio,
#          charge of electron, mass of ion, electric field, gravitational
#          acceleration, centrifugal force, momentum exchange rate, energy
#          exchange rate, mass production rate, spatial step, updated mass
#          density from density_lax_ion, updated velocity from
#          velocity_lax_ion
#ref: Gombozi+1985, Glocer+ 2007 etc
    import numpy as np
    Z = (0.5*((np.roll(A*rho*u*u,-1))+(np.roll(A*rho*u*u,1))))
    Y = (np.roll(A*P,-1)+np.roll(A*P,1))*(1/(gamma-1))
    X = (0.5*(np.roll(A*rho*u*u*u,-1)+np.roll(A*rho*u*u*u,1)))
    W = (np.roll(A*u*P,-1)+(np.roll(A*u*P,1)))*(gamma/(gamma-1))
    V = (A*u*rho*(((e_charge/m_i)*E)-ag+ac))
    phi = V + dMdt + dEdt + 0.5*A*u*u*S
    old = (0.5*rho_new*u_new*u_new)

    new_P = (((0.5*(Z+Y)) - ((0.5*dt/dx)*(X-W)) + dt*phi - old)/((gamma-1)/A))
    P = new_P[2:-2]
    return P

# OLD SECTION PRE-ROLL FUNCTION
    # Z = ((0.5*A_1*rho_1*u_1*u_1)+(A_1*P_1*(1/(gamma-1))))
    # Y = ((0.5*A_0*rho_0*u_0*u_0)+(A_0*P_0*(1/(gamma-1))))
    # X = ((0.5*A_1*rho_1*u_1*u_1*u_1)-(A_1*u_1*P_1*(gamma/(gamma-1))))
    # W = ((0.5*A_0*rho_0*u_0*u_0*u_0)-(A_0*u_0*P_0*(gamma/(gamma-1))))
    # V = ((A*u*rho*((e_charge/m_i)*E-ag+ac)))
    #return ((((0.5*(Z)+(Y))-((dt/(2*dx))*(X)-(W))+(dt*((V)+dMdt +dEdt +(0.5*A*u*u*S))))-(0.5*A*rho_new*u_new*u_new))*((gamma-1)/A))
#input as: dt,A[i],A[i-1],A[i+1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][2:-2:,i-1],tmp_ions[l]["rho"][2:-2,i+1],tmp_ions[l]["u"][2:-2,i],tmp_ions[l]["u"][2:-2,i-1],tmp_ions[l]["u"][2:-2,i+1],ions[l]["P"][2:-2,i-1],ions[l]["P"][2:-2,i+1],gamma,e_charge,ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],dEdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i],ions[l]["u"][2:-2,i]
#          dt,A[2:-2],A[1:-3],A[3:-1],tmp_ions[l]["rho"][2:-2,i],tmp_ions[l]["rho"][1:-3:,i],tmp_ions[l]["rho"][3:-1,i],tmp_ions[l]["u"][2:-2,i],tmp_ions[l]["u"][1:-3,i],tmp_ions[l]["u"][3:-1,i],ions[l]["P"][1:-3,i],ions[l]["P"][3:-1,i],gamma,e_charge,ions[l]["mass"],E[2:-2,i],-ag,ac,dMdt[2:-2,l-1],dEdt[2:-2,l-1],ions[l]["S"][2:-2],dz,ions[l]["rho"][2:-2,i],ions[l]["u"][2:-2,i]
#(dt,A,A_0,A_1,rho,rho_0,rho_1,u,u_0,u_1,P_0,P_1,gamma,e_charge,m_i,E,ag,ac,dMdt,dEdt,S,dx,rho_new,u_new):

def temperature_electron(dt,A,rho,u,T,gamma,S,dx):
#returns: electron temperature
#requires: time step,area vectors for current, previous grid position and
#          next grid position, mass density for current grid position,
#          velocity of current, previous and next grid position, temperature
#          temperature at previous and current grid position, gamma, mass
#          production rate, spatial step
#ref: Gombozi+1985, Glocer+ 2007 etc
    import numpy as np
    Z = (rho*u*(dt/(2*dx))*(np.roll(T,-1)+np.roll(T,1)))
    Y = (T*dt*(S+((gamma-1)/A)*rho*(1/(2*dx))))
    X = (np.roll(A*u,-1)+np.roll(A*u,1))
    W = (np.roll(T,-1)+np.roll(T,1))

    new_T = ((0.5*W)+(Z-(Y*X)/rho))
    T = new_T[2:-2]

    return T

# OLD SECTION PRE-ROLL FUNCTION
    # Z = (rho*u*(dt/(2*dx))*(T_1-T_0))
    # Y = (T*dt*(S+((gamma-1)/A)*rho*(1/(2*dx))*((A_1*u_1)-(A_0*u_0))))
    # return((0.5*(T_1-T_0))+((Z)-(Y)/rho))
#input as: dt,A[i],A[i-1],A[i+1],electrons["rho"][2:-2,i],electrons["u"][2:-2,i],electrons["u"][2:-2,i-1],electrons["u"][2:-2,i+1],electrons["T"][2:-2,i],electrons["T"][2:-2,i-1],electrons["T"][2:-2,i+1],gamma,electrons["S"][2:-2],dz
#          dt,A[2:-2],A[1:-3],A[3:-1],electrons["rho"][2:-2,i],electrons["u"][2:-2,i],electrons["u"][1:-3,i],electrons["u"][3:-1,i],electrons["T"][2:-2,i],electrons["T"][1:-3,i],electrons["T"][3:-1,i],gamma,electrons["S"][2:-2],dz
